---
title: "Data Correction and Imputation"
author: "Fadel Megahed"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    number_sections: TRUE
    code_download: TRUE
    code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Missing Data


## Plots and Counting Missing Per Col
```{r induce_missing}
iris_df = iris

# will plot all your columns and show the percent missing in each col
DataExplorer::plot_missing(iris_df)

# use the is.na() and apply it to each col
t_f_sepal_length = is.na(iris_df$Sepal.Length) # this will return a vect of TRUE and False where FALSE means no missing data
count_missing_sepal_length = sum(t_f_sepal_length)
frac_missing_sepal_length = count_missing_sepal_length/nrow(iris_df)

# using this logic, we can create a function that checks is.na and then sums (do percent/fraction)
frac_missing = function(x){
  # x will be a vector
  out = is.na(x) |> sum()
  out = out/length(x)
  return(out)
}

# similar to map_df but I want to return a numeric vector where element will correspond to a column in iris df
fract_mission_in_iris = purrr::map_dbl(.x = iris_df, frac_missing)
```

## Inducing Missing Data

```{r iris_missing}
iris_missing = iris_df
iris_missing[1:10, 1] = NA # take rows 1:10 and set it to NA
```


# Mean Imputation (Terrible in Practice)

This is not great in practice since it will change the distribution of your variable. **I am only showing it since it is a common starting point for data imputation**.

```{r mean_imputation}
mean_col1 = mean(x = iris_missing$Sepal.Length, na.rm = T)
median_col1 = median(x = iris_missing$Sepal.Length, na.rm = T)

# a terrible way of imputing
iris_complete_naive_imputation = iris_missing |> 
  tidyr::replace_na(
    replace = list(Sepal.Length = median_col1)
  )

head(iris_complete_naive_imputation, 20)
```

Why is the mean/median imputation a terrible approach for data imputation?  

1. They will change the distribution of your column and reduce its variance.  
2. By taking mean/median for the col, we are using the entire dataset (and **ignoring the existing values in our observation**).


# The KNN imputation approach

```{r}
iris_imputation_knn = VIM::kNN(iris_missing, k = 5)
```





















